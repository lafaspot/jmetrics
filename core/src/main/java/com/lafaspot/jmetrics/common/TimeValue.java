/*
 * Copyright [yyyy] [name of copyright owner]
 * 
 * ====================================================================
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *  ====================================================================
 */

package com.lafaspot.jmetrics.common;

import java.util.HashMap;
import java.util.Locale;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;

/**
 * Physical quantities with units of time, and 64-bit integer values.
 *
 * @author sgrennan
 *
 */
public final class TimeValue implements java.io.Serializable, Comparable<TimeValue> {

	/**
	 * Creates a time quantity with the specified numeric value and units.
	 *
	 * @param value the magnitude of the time interval (positive, negative or zero)
	 * @param timeUnit the units of the interval
	 */
    public TimeValue(final long value, final TimeUnit timeUnit) {
		super();
		this.value = value;
		this.timeUnit = timeUnit;
	}

	/**
	 * Returns a time value equal to the current JVM time.
	 *
	 * @return the current time
	 */
	public static TimeValue now() {
		return new TimeValue(System.currentTimeMillis(), TimeUnit.MILLISECONDS);
	}

	/**
	 * Compares this value to {@code o}, returning 1, 0 or -1 as this value is greater than, equal to or less than {@code o}, respectively.
	 * (Implementation of {@link Comparable}.
	 *
	 * @return -1, 0 or 1 as this value is less than, equal to or greater than {@code o}.
	 * @throws IllegalArgumentException if {@code o} is null.
	 */
	@Override
	public int compareTo(@Nonnull final TimeValue o) {
		if (o == null) {
			throw new IllegalArgumentException("Cannot compare to null TimeValue.");
		}
		// Same units? Just compare values.
		final int unitCompare = timeUnit.compareTo(o.timeUnit);
		if (unitCompare == 0) {
			if (this.value < o.value) {
				return -1;
			}
			if (this.value > o.value) {
				return 1;
			}
			return 0;
		}
		// Convert larger-united quantity to smaller units.
		final TimeValue bigU = (unitCompare < 0) ? o : this;
		final TimeValue smallU = (unitCompare < 0) ? this : o;
		final long convertedValue = smallU.timeUnit.convert(bigU.value, bigU.timeUnit);
		/*
		 * Is the converted value now greater or smaller? Overflow or underflow means the larger-united quantity cannot be represented in the smaller
		 * units, which means it has to be greater or smaller, respectively. NB: it is not possible for Long.MAX_VALUE or Long.MIN-VALUE to be
		 * generated by any unit conversion, as they are not evenly divisible by 24, 60 or 1000.
		 */
		if (convertedValue == Long.MAX_VALUE || convertedValue > smallU.value) {
			return (bigU == this) ? 1 : -1;
		}
		if (convertedValue == Long.MIN_VALUE || convertedValue < smallU.value) {
			return (bigU == this) ? -1 : 1;
		}
		return 0;
	}

	/**
	 * A regular expression separating the configuration string into a whole number and units, in such a way that the number will parse as a long
	 * without exception, and the units specifier cannot be null or missing (but may be any case). TODO fsg 110504 Add floating-point.
	 */
	private static Pattern timeValueRegex = Pattern.compile("\\s*(\\d+)(\\s*)([a-zA-Z]+)\\s*");

    /** Primitive type value. */
	private final long value;
	/** TimeUnit object. */
	private final TimeUnit timeUnit;
    /**
     * 
     * @return the long value
     */
	public long getValue() {
		return value;
	}

	/**
	 * @return the timeUnit object
	 */
	public TimeUnit getTimeUnit() {
		return timeUnit;
	}

    /** 
     * convert to long value to days.
     * 
     * @return the value converted to days
     */
	public long toDays() {
		return timeUnit.toDays(value);
	}

    /**
     * convert to long value to hours.
     * 
     * @return the value converted to hours
     */
	public long toHours() {
		return timeUnit.toHours(value);
	}

    /**
     * convert to long value to micros.
     * 
     * @return the value converted to micros
     */
	public long toMicros() {
		return timeUnit.toMicros(value);
	}

    /**
     * convert to long value to millis.
     * 
     * @return the value converted to millis
     */
	public long toMillis() {
		return timeUnit.toMillis(value);
	}

    /**
     * convert to long value to minutes.
     * 
     * @return the value converted to minutes
     */
	public long toMinutes() {
		return timeUnit.toMinutes(value);
	}

    /**
     * convert to long value to seconds.
     * 
     * @return the value converted to seconds
     */
	public long toSeconds() {
		return timeUnit.toSeconds(value);
	}

    /**
     * HashCode method.
     * 
     * @return the hashcode.
     */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + ((timeUnit == null) ? 0 : timeUnit.hashCode());
		result = prime * result + (int) (value ^ (value >>> 32));
		return result;
	}

    /**
     * Equals method.
     * 
     * @return true if the two objects are equal else false
     */
	@Override
	public boolean equals(final Object that) {
		if (!(that instanceof TimeValue)) {
			return false;
		}
		return compareTo((TimeValue) that) == 0;
	}

    /**
     * Parse string to get TimeValue object.
     * @param value to be parsed and converted.
     * @return the TimeValue object.
     * @throws TypeFormatException when error while parsing the input value string
     */
	public static TimeValue parse(final String value) throws TypeFormatException {
		final Matcher matcher = timeValueRegex.matcher(value);
		if (matcher.find()) {
			final long longVal = Long.parseLong(matcher.group(1));
			final TimeUnit units = ABBREVIATION_TO_UNIT.get(matcher.group(3).toLowerCase(Locale.US));
			if (units != null) {
				return new TimeValue(longVal, units);
			} else {
				throw new TypeFormatException("Time units [d,h,m,s,ms,us,ns] missing from '" + value + "'");
			}
		} else {
			throw new TypeFormatException("Unable to parse time 'NUMBER d|h|m|s|ms|us|ns' from '" + value + "'");
		}
	}
    /**
     * Convert TimeValue object to string.
     * 
     * @return the string representation of TimeValue object
     */
	@Override
	public String toString() {
		return value + " " + UNIT_TO_ABBREVIATION.get(timeUnit);
	}

    /**
     * Unit to abbreviation mapping.
     * 
     */
	private static final HashMap<TimeUnit, String> UNIT_TO_ABBREVIATION = new HashMap<TimeUnit, String>();
	static {
		UNIT_TO_ABBREVIATION.put(TimeUnit.NANOSECONDS, "ns");
		UNIT_TO_ABBREVIATION.put(TimeUnit.MICROSECONDS, "us");
		UNIT_TO_ABBREVIATION.put(TimeUnit.MILLISECONDS, "ms");
		UNIT_TO_ABBREVIATION.put(TimeUnit.SECONDS, "s");
		UNIT_TO_ABBREVIATION.put(TimeUnit.MINUTES, "m");
		UNIT_TO_ABBREVIATION.put(TimeUnit.HOURS, "h");
		UNIT_TO_ABBREVIATION.put(TimeUnit.DAYS, "d");
	}
    /**
     * Abbreviation to Unit mapping.
     */
	private static final HashMap<String, TimeUnit> ABBREVIATION_TO_UNIT = new HashMap<String, TimeUnit>();
	static {
		ABBREVIATION_TO_UNIT.put("ns", TimeUnit.NANOSECONDS);
		ABBREVIATION_TO_UNIT.put("us", TimeUnit.MICROSECONDS);
		ABBREVIATION_TO_UNIT.put("ms", TimeUnit.MILLISECONDS);
		ABBREVIATION_TO_UNIT.put("s", TimeUnit.SECONDS);
		ABBREVIATION_TO_UNIT.put("m", TimeUnit.MINUTES);
		ABBREVIATION_TO_UNIT.put("h", TimeUnit.HOURS);
		ABBREVIATION_TO_UNIT.put("d", TimeUnit.DAYS);
	}

	/** Required by Serializable. */
	private static final long serialVersionUID = 8439678036575756604L;
}